---
title: 深入浅出Webpack
description: 关于深入《浅出webpack》的读书笔记
categories:
- 实用工具
tags:
- webpack
- 工具
---

### webpack核心
* entry：入口，构建从入口开始
* module：模块，在webpack中一个模块就是一个文件
* chunk：代码块，多个模块集合，方便合并分割
* loader：模块转换器，用于将模块按照需求转换
* Plugin：扩展插件，在Webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果或做我们想要的事情。
* Output：输出结果，在Webpack经过一系列处理并得出最终想要的代码后输出结果。Webpack在启动后会从Entry里配置的Module开始，递归解析Entry依赖的所有Module。  

- - -  
### 遇到问题汇总
1. 文件夹名称不能使用webpack
2. 当使用webpacck4.0时`extract-text-webpack-plugin`这个插件（为css生产单文件）必须使用`^4.0.0-bet.0`版本
3. 在开启热启动，开发服务器，sourcemap时要这么写`webpack-dev-server --config--hot--devtool source-map --config webpack.config.js`不然会报错
4. webpack4.0使用`hash`去替代`contenthash`


---
### webpack配置
webpack有如下两种配置方式
1. 通过一个JavaScript文件描述配置，例如使用webpack.config.js文件里的配置；
2. 执行Webpack可执行文件时通过命令行参数传入，例如webpack--devtoolsource-map。
按照配置所影响的功能来划分，可分为如下内容。  

#### Entry
配置模块的入口,webpack将从入口递归解析出所有的依赖模块  
entery是*必填项*，否则会导致webpack报错退出  
##### context  
webpack在寻找相对路径文件时会以context为根目录，默认下context为webpack命令执行目录，可以通过如下方法改变：
```js
  module.export = {
    context: path.resolve(__dirname, 'app')
  }
```
context必须为绝对路径，也可以在启动时使用`webpack --context` 来设置  
- - - -  
##### entry类型  
可以是字符串，数组和对象
  * 字符串  
    `'./app/entry'`  
    入口模块的文件路径，可以是相对路径。  
  * 数组  
    `['./app/entry1', './app/entry2']`  
    入口模块的文件路径，可以是相对路径。  
    如果是 array 类型，则搭配 output.library 配置项使用时，只有数组里的最后一个入口文件的模块会被导出。
  * 对象  
    `{ a: './app/entry-a', b: ['./app/entry-b1', './app/entry-b2']}`  
    配置多个入口，每个入口生成一个 Chunk  

- - - -
##### chuck名称  
Webpack会为每个生成的Chunk取一个名称，Chunk的名称和Entry的配置有关。
如果entry是一个string或array，就只会生成一个Chunk，这时Chunk的名称是main。
如果entry是一个object，就可能会出现多个Chunk，这时Chunk的名称是object键值对中键的名称。
- - - -  
##### 动态entry
  ```js
    // 同步
    entry: () => {
      return {
        a: './pages/a',
        b: './pages/b'
      }
    }
    // 异步
    entry: () => {
      return new Promise((resolve) => {
        resolve({
          a: './pages/a',
          b: './pages/b'
        })
      })
    }
  ```  

---
#### Output  
配置如何输出最终想要的代码
##### filename
配置输出文件名称，为string类型  
如果输出为一个文件可以使用一个固定的文件名，**如果输出多个文件（`entry`为对象）则需要使用`[name].js`的写法**
  ```js
    // 单个文件
    filename: 'bundle.js'
    // 多个文件
    // 通过内置的name变量去生成文件名
    filename: '[name].js'
  ```
除了name，webpack还提供了其他变量  
* id:唯一标识从0开始  
* hash：唯一标识hash值  
* chuckhash：chuck内容hash值  

后两者可以通过[hash:n]来指定长度，n为长度  
  
- - - -
##### chuckfilename
用来配置无入口的chuck名称
- - - -
##### path
用来配置输出路径，必须是绝对路径
```js
path: path.resolve(__dirname,'dist[hash]')
```
- - - -
##### publicpath  
在复杂的项目里可能会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的URL地址。output.publicPath配置发布到线上资源的URL前缀，为string类型。默认值是空字符串''，即使用相对路径。  
比如需要将构建出的资源文件上传到CDN服务上，以利于加快页面的打开速度。
```js
filename:'[name]_[chunkhash:8].js'
publicPath: 'https://cdn.example.com/assets/'
```
```html
<script src='https://cdn.example.com/assets/a_12345678.js'></script>
```  
- - - -  
##### crossOriginLoading
Webpack 输出的部分代码块可能需要异步加载，而异步加载是通过 JSONP 方式实现的。  
`output.crossOriginLoading`则是用于配置这个异步插入的标签的`crossorigin`值。
* anonymous(默认) 在加载此脚本资源时不会带上用户的 Cookies；
* use-credentials 在加载此脚本资源时会带上用户的 Cookies。  
   
- - - -
##### libraryTarget 和 library
当用 Webpack 去构建一个可以被其他模块导入使用的库时需要用到它们。
* `output.libraryTarget`配置以何种方式导出库。
* `output.library`配置导出库的名称。  
它们通常搭配在一起使用。  

`output.libraryTarget`是字符串的枚举类型，支持以下配置。
* var(默认)  
  ```js
  // Webpack 输出的代码(output.library='LibraryName')
  var LibraryName = lib_code;
  // output.library为空则直接输出
  lib_code

  // 使用库的方法
  LibraryName.doSomething();
  ```
* commonjs
  ```js
  // Webpack 输出的代码(output.library='LibraryName')
  exports['LibraryName'] = lib_code;

  // 使用库的方法
  require('library-name-in-npm')['LibraryName'].doSomething();
  ```
  > `library-name-in-npm`为发布到npm的名称
* commonjs2
  ```js
  // Webpack 输出的代码
  module.exports = lib_code;

  // 使用库的方法
  require('library-name-in-npm').doSomething();
  ```
  > 此时`output.library`没有意义
* this
  ```js
  // Webpack 输出的代码
  this['LibraryName'] = lib_code;

  // 使用库的方法
  this.LibraryName.doSomething();
  ```
* window
  ```js
  // Webpack 输出的代码
  window['LibraryName'] = lib_code;

  // 使用库的方法
  window.LibraryName.doSomething();
  ```
* global
  ```js
  // Webpack 输出的代码
  global['LibraryName'] = lib_code;

  // 使用库的方法
  global.LibraryName.doSomething();
  ```

  - - - -
##### libraryExport
`output.libraryExport`配置要导出的模块中哪些子模块需要被导出。 它只有在`output.libraryTarget`被设置成`commonjs`或者`commonjs2`时使用才有意义。  
需要导出的模块
```js
export const a=1;
export default b=2;
```
把`libraryExport`设成`a`  
```js
// Webpack 输出的代码
module.exports = lib_code['a'];

// 使用库的方法
require('library-name-in-npm')===1;
```
- - - -
#### Module：配置处理模块的规则。

#### Resolve：配置寻找模块的规则。
#### Plugins：配置扩展插件。
#### DevServer：配置DevServer。
#### 其他配置项：其他零散的配置项。










 
#前端/工具/webpack
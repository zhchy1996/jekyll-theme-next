---
title: 数据结构(按大纲整理)
description: 数据结构
categories:
 - 考研
tags:
 - 数据结构
---
# 考纲
![](http://image.zhchy.info/20191105181125_yHsZYG_Screenshot.jpeg)
- - -
# 数组与矩阵
## 一维数组与二维数组的存储
数组一般情况下采用顺序存储结构  
### 一维数组
若一维数组的每个元素占k个存储单元,并且从地址1开始存储数组的第1个元素,则数组第ⅰ个元素的存储位置LOC(ai)可由下式确定  
LOC(ai) = LOC(ai) + (i - 1)*k = l0 + (i - 1) * k  
### 二维数组
若已知元素a1的存储地址为LOC(a1),并且每个元素占用k个存储单元,则数组第i行第j列的元素a的存储位置为  
LOC(aij) = LOC(a11) + (i - 1) * n * k + (j - 1) * k    
         = LOC(a11) + [(i - 1) * n + (j - 1)] * k  
- - -
## 矩阵压缩

- - -
# 树与二叉树
## 基本概念
### 术语
![](http://image.zhchy.info/20191105180830_3IgOHV_Screenshot.jpeg)
* 结点的度:结点拥有的子树个数或者分支的个数。例如,A结点有3棵子树,所以A结点的度为3
* 树的度:树中各结点度的最大值。如例子中结点度最大为3(A、D结点),最小为0(F、G、1、J K、L、M结点),所以树的度为3。
* 祖先:从根到某结点的路径上的所有结点,都是这个结点的祖先。如K的祖先是AB、E,因为从A到K的路径为A-B-E一K。
* 层次:从根开始,根为第一层,根的孩子为第二层,根的孩子的孩子为第三层,以此类推。
* 树的高度(或者深度):树中结点的最大层次。如例子中的材共有4层,所以高度为4。
* 结点的深度和高度:   
  * 结点的深度是从根结到该结点路径上的结点个数  
  * 从某结点往下走可能到达多个叶子结点,对应予多条通往这些叶子结点的路径,其中最长的那条路径的长度即为该结点在树中的高度,如结点D的高度为3、就是从D到M的路径长度。  
  * 根结点的高度为树的高度,如结点A,其高度为4。是从A到K(L、M)这条路径的长度,也是整棵树的高度。
* 有序树:树中结点的子树从左到右是有次序的,不能交换,这样的树叫作有序树。
* 无序树:树中结点的子树没有顺序,可以任意交换,这样的树叫作无序树
* 丰满树:丰满树即理想华衡树、要求除最底层外,其他层都是满的

- - -

# 排序
## 折半查找
### 判定树
折半査找的过程可以用二叉树来表示。把当前査找区间中的中间位置上的记录作为树根,左子表和右子表中的记录分别作为根的左子树和右子树,由此得到的二叉树称为描述折半查找的判定树。例如, 对于序列{1,2,3,4,5,6,7,8,9,10,11}可以做出一棵判定树,如图9-1所示,图中叶子结点(方框所示)代表查找不成功的位置。由图9-1可知,折半査找的比较次数即为从根结点到待查找元素所经过的结点数,其比较次数最多的情况即为一直走到叶子结点的情况。因此,算法的时间复杂度可以用树的高度来表示。推广到一般情况,对于有n个记录的查找表,进行折半査找的时间复杂度为log2n。折查找的平均查找长度近似为log2(n+l)-1,严版课本中有推导过程,了解但可不作重点。
![](http://image.zhchy.info/20191107155047_cnGp8c_Screenshot.jpeg)

- - -
# 图
## 基本概念
1. 图  
由结点的有穷集合V和边的集合E组成。为了与树形结构进行区别,在图结构中常常将结点称为边是顶点的有序偶对。若两个顶点之间存在一条边,则表示这两个顶点具有相邻关系
2. 有向图和无向图  
每条边都有方向是有向图，每条边都没有方向是无向图
3. 弧
在有向图中,通常将边称为弧,含箭头的一端称为弧头,另一端称为弧尾,记作&lt;Vi,Vj&gt;,它表示从顶点v到顶点v有一条边。
5. 有向完全图和无向完全图
若有向图中有n个顶点,则最多有n(n-1)条边(图中任意两个顶点都有两条边相连),将具有n(n-1) 条边的有向图称为有向完全图。若无向图中有n个顶点,则最多有n(n-1)/2条边(任意两个顶点之间都有一条边),将具有n(n-1)/2条边的无向图称为无向完全图。
6. 路径和路径长度
在一个图中,路径为相邻顶点序偶所构成的序列。路径长度是指路径上边的数目。例如,在图7-1a 中,<C,B>、<B,A>是一条路径,长度为2:在图7-1b中,(D,C)、(C,B)、(B,A)是一条路径, 长度为3
![](http://image.zhchy.info/20191113113127_77TdmH_Screenshot.jpeg)
7. 简单路径
序列中顶点不重复出现的路径称为简单路径。
8. 回路
若一条路径中第一个顶点和最后一个顶点相同,则这条路径是一条回路。
9. 连通、连通图和连通分量
在无向图中,如果从顶点v到顶点y有路径,则称v和y连通。**如果图中任意两个顶点之间都连通,则称该图为连通图**:否则,图中的极大连通子图称为**连通分量**。如在图7-2中,图7-2c是一个非连通图它由图7-2a和图7-2b组成,图7-2a和图7-2b都是连通图。对于图7-2c、图7-2a和图7-2b就是它的两个连通分量。
![](http://image.zhchy.info/20191113113412_HJywpB_Screenshot.jpeg)
10. 强连通图和强连通分量
在有向图中,若从Vi到Vj有路径,则称从Vi到Vj是连通的。如果对于每一对顶点Vi和Vj,**从Vi到Vj和Vj到Vi都有路径,则称该图为强连通图**;否则,将其中的极大强连通子图称为**强连通分量**。
11. 权和网
图中每条边都可以附有一个对应的数,这种与边相关的数称为权。权可以表示从一个顶点到另一个顶点的距离或者花费的代价。边士错有权的图称为带权图,也称为网。
- - -
## 邻接矩阵和邻接表
### 邻接矩阵
#### 概念
邻接矩阵是图的**顺序存储结构**，对于无向图，邻接矩阵是对称的，矩阵中“1”的个数是图中总边数的2倍，矩阵中第i行或第i列的元素之和即为顶点i的度。  
对于有向图，矩阵中“1”的各处为图的边数，矩阵中第i行的元素之和为顶点i的出度，第j列为顶点i的入度。
![](http://image.zhchy.info/20191113151220_KD0dnQ_Screenshot.jpeg)  
#### 结构  
  ```c
    // 图节点定义
    typedef struct
    {
      int no;
      char info;
    }VertexType;

    // 图的定义
    typedef struct
    {
      int edges[maxSize][maxSize]; // 邻接矩阵定义，如果是有权图，将int改为float
      int n, e;                    // 存放定点数和边数
      VertexType vex[maxSize];
    } MGraph;
  ```  
有时给出压缩矩阵写法，三元组表示，只需要知道三元组原理即可
### 邻接表
#### 概念
邻接表是图的一种链式存储结构。所邻接表就是对图中的每个顶点i建立一个单链表,每个单链表的第一个结点存放有关顶点的信把这点看作链表的表头,其余结点存放有关边的信息,因此邻接表由单链表的表头形成的顶点表利单链表其余结点形成的边表两部分组成。一般顶点表存放顶点信息和指向第一个边结点指针,边表结点存放与当前顶点相邻接顶点的序号和指向下一个边结点的指针。
![](http://image.zhchy.info/20191113155903_cLKFuj_Screenshot.jpeg)  
#### 结构  
  ```c
  // 定义边结构
    typedef struct ArcNode
    {
      int adjvex;              // 该边指向结点的位置
      struct ArcNode *nextarc; // 指向下一条边信息
      int info;                // 该边的相关信息，如权值，这一句用的不多
    } ArcNode;
    // 定义顶点结构
    typedef struct
    {
      char data;
      ArcNode *firstarc; // 指向第一条边的指针
    } VNode;
    typedef struct
    {
      VNode adjlist[maxSize]; //邻接表
      int n, e;               // 顶点数和边数
    } AGraph
  ```
### 逆邻接表
逆邻接表与邻接表相似，只是邻接表存储的是每个节点的出度，而逆邻接表存储的是入度。  
![](http://image.zhchy.info/20191113160721_EK5Rw9_Screenshot.jpeg)  

- - -
## 图的深度优先搜索和广度优先搜索
图的深度优先搜素遍历(DFS)类似于二叉树的先序遍历。它的基本思想是:首先访问出发点v并将其标记为已访问过;然后选取与v邻接的未被访问的任意一个顶点w,并访问它;再选取与w邻接的未被访间的任一顶点并访问,以此重复进行。当一个顶点所有的邻接顶点都被访问过时,则依次退回到最近被访问过的顶点,若该顶点还有其他邻接顶点未被访问,则从这些未被访问的顶点中取一个并重复上述访问过程,直至图中所有顶点都被访问过为止。图7-8所示即为一个图的深度优先搜索遍历过程。  
![](http://image.zhchy.info/20191113161502_WEI4wU_Screenshot.jpeg)



























---
title: es6总结
description:   参考1.5万字概括ES6全部特性,ECMAScript 6入门
categories:
 - 面试
tags:
 - js
 - 面试
---

[1.5万字概括ES6全部特性](https://juejin.im/post/5d9bf530518825427b27639d)  
[ECMAScript 6入门](https://es6.ruanyifeng.com/)

# 解构赋值
应用：
* 交换变量值：`[x, y] = [y, x]`
* 返回函数多个值：`const [x, y, z] = Func()`
* 定义函数参数：`Func([1, 2])`
* 提取JSON数据：`const { name, version } = packageJson`
* 定义函数参数默认值：`function Func({ x = 1, y = 2 } = {}) {}`
* 遍历Map结构：`for (let [k, v] of Map) {}`
* 输入模块指定属性和方法：`const { readFile, writeFile } = require("fs")`

- - -
# 字符串扩展

* Unicode表示法：大括号包含表示Unicode字符(\u{0xXX}或\u{0XXX})
* 字符串遍历：可通过for-of遍历字符串
  ```js
    for(let a of 'abc'){
      console.log(a);
    }
  ```
* 字符串模板：可单行可多行可插入变量的增强版字符串
* `String.raw()`：返回把字符串所有变量替换且对斜杠进行转义的结果
* `String.fromCodePoint()`：返回码点对应字符
* `codePointAt()`：返回字符对应码点(String.fromCodePoint()的逆操作)
* `repeat()`：把字符串重复n次，返回新字符串
* `matchAll()`：返回正则表达式在字符串的所有匹配
* `includes()`：是否存在指定字符串
* `startsWith()`：是否存在字符串头部指定字符串
* `endsWith()`：是否存在字符串尾部指定字符串
**以上方法均用于4个字节存储的Unicode字符上**

- - -
# 数值扩展
* 二进制表示法：0b或0B开头表示二进制(0bXX或0BXX)
* 八进制表示法：0o或0O开头表示二进制(0oXX或0OXX)
* `Number.parseInt()`：返回转换值的整数部分
* `Number.parseFloat()`：返回转换值的浮点数部分
* `Number.isFinite()`：是否为有限数值
* `Number.isNaN()`：是否为NaN
* `Number.isInteger()`：是否为整数
* `Math.trunc()`：返回数值整数部分
* `Math.sign()`：返回数值类型(正数1、负数-1、零0)

- - -
# 对象扩展
* 简洁表示法：直接写入变量和函数作为对象的属性和方法  
  ```js
    { 
      prop, 
      method() {}
    }
  ```
* 属性名表达式：字面量定义对象时使用`[]`定义键
  ```js
    // 不能与上面的特性同时使用
    let foo = 'bar';
    {
      [foo]: 'foo',
      // 这样是不行的
      [foo]
    }
  ```
* 方法的name属性：返回方法函数名
  ```js
    // 如果是get和set则不能直接取到name，需要通过描述符来访问
    const obj = {
      get foo() {},
      set foo(x) {}
    };

    obj.foo.name
    // TypeError: Cannot read property 'name' of undefined

    const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
    // 这个方法会返回一个对象里面的内容如下
    /**
    {
      value: 1 // descriptor没有这个值,以get代替
      writable: true // descriptor没有这个值,以set代替
      enumerable: true
      configurable: true
    }
    */

    descriptor.get.name // "get foo"
    descriptor.set.name // "set foo"
    // 通过new Function创建的函数
    (new Function()).name // "anonymous"
    // bind函数返回的函数
    var doSomething = function() {
      // ...
    };
    doSomething.bind().name // "bound doSomething"
  ```
* 属性的可枚举性和遍历：描述对象的enumerable
* super关键字：指向当前对象的原型对象(**只能用在对象的简写方法中method() {}**)
* `Object.is()`：对比两值是否相等
* `Object.assign()`：合并对象(浅拷贝)，返回原对象
* `Object.getPrototypeOf()`：返回对象的原型对象
* `Object.setPrototypeOf()`：设置对象的原型对象
* `__proto__`：返回或设置对象的原型对象

## 属性遍历
* 描述：自身、可继承、可枚举、非枚举、Symbol
* 遍历
  `for-in`：遍历对象自身可继承可枚举属性
  `Object.keys()`：返回对象自身可枚举属性的键组成的数组
  `Object.getOwnPropertyNames()`：返回对象自身可继承可枚举非枚举属性的键组成的数组
  `Object.getOwnPropertySymbols()`：返回对象Symbol属性的键组成的数组
  `Reflect.ownKeys()`：返回对象自身可继承可枚举非枚举Symbol属性的键组成的数组
* 规则
  首先遍历所有数值键，按照数值升序排列  
  其次遍历所有字符串键，按照加入时间升序排列  
  最后遍历所有Symbol键，按照加入时间升序排列  

- - -
# 数组扩展
* 扩展运算符(...)：转换数组为用逗号分隔的参数序列(`[...arr]`，相当于rest/spread参数的逆运算)
* `Array.from()`：转换具有Iterator接口的数据结构为真正数组，返回新数组
* 类数组对象：包含length的对象、Arguments对象、NodeList对象
* 可遍历对象：String、Set结构、Map结构、Generator函数  

* `Array.of()`：转换一组值为真正数组，返回新数组
* `copyWithin()`：把指定位置的成员复制到其他位置，返回原数组
* `find()`：返回第一个符合条件的成员
* `findIndex()`：返回第一个符合条件的成员索引值
* `fill()`：根据指定值填充整个数组，返回原数组
* `keys()`：返回以索引值为遍历器的对象
* `values()`：返回以属性值为遍历器的对象
* `entries()`：返回以索引值和属性值为遍历器的对象,[0, 1]
* 数组空位：ES6明确将数组空位转为undefined(空位处理规不一，建议避免出现,chrome使用empty处理)

## 扩展应用
* 克隆数组：`const arr = [...arr1](浅克隆)`
* 合并数组：`const arr = [...arr1, ...arr2]`
* 拼接数组：`arr.push(...arr1)`
* 代替apply：`Math.max.apply(null, [x, y]) => Math.max(...[x, y])`
* 转换字符串为数组：`[..."hello"]`
* 转换类数组对象为数组：`[...Arguments, ...NodeList]`
* 转换可遍历对象为数组：`[...String, ...Set, ...Map, ...Generator]`
* 与数组解构赋值结合：`const [x, ...rest/spread] = [1, 2, 3]`
* 计算Unicode字符长度：`Array.from("hello").length => [..."hello"].length`

## 重点难点
使用`keys()、values()、entries()`返回的遍历器对象，可用`for-of`自动遍历或`next()`手动遍历

- - -
# 函数扩展

* 参数默认值：为函数参数指定默认值
  * 形式：function Func(x = 1, y = 2) {}  
  * 参数赋值：惰性求值(函数调用后才求值)  
  * 参数位置：尾参数  
  * 参数作用域：函数作用域  
  * 声明方式：默认声明，不能用const或let再次声明  
  * **length：返回没有指定默认值的参数个数**  
  * 与解构赋值默认值结合：function Func({ x = 1, y = 2 } = {}) {}
  * 应用  
    指定某个参数不得省略，省略即抛出错误：`function Func(x = throwMissing()) {}`  
    将参数默认值设为undefined，表明此参数可省略：`Func(undefined, 1)`
* rest/spread参数(...)：返回函数多余参数
  形式：以数组的形式存在，之后不能再有其他参数  
  作用：代替Arguments对象  
  length：返回没有指定默认值的参数个数但不包括rest/spread参数  
* 严格模式：在严格条件下运行JS
  应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式
* name属性：返回函数的函数名
  * 将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6)
  * 将具名函数赋值给变量：函数名(ES5和ES6)
  * bind返回的函数：bound 函数名(ES5和ES6)
  * Function构造函数返回的函数实例：anonymous(ES5和ES6)
* 箭头函数(=>)：函数简写
  * 无参数：`() => {}`
  * 单个参数：`x => {}`
  * 多个参数：`(x, y) => {}`
  * 解构参数：`({x, y}) => {}`
  * 嵌套使用：部署管道机制
    ```js
    // 返回一个函数接受val参数，作为数组的reduce的第一个参数，也就是a，然后在调用传入的第一个参数的时候就会将a作为参数
    const pipeline = (...funcs) =>
      val => funcs.reduce((a, b) => b(a), val);

    const plus1 = a => a + 1;
    const mult2 = a => a * 2;
    const addThenMult = pipeline(plus1, mult2);

    addThenMult(5)
    ```
  * 注意点 
    * this指向固定化
      **并非因为内部有绑定this的机制，而是根本没有自己的this，导致内部的this就是外层代码块的this**  
      **因为没有this，因此不能用作构造函数**
    * 不能使用arguments对象
    * 不能使用yield命令，不能做Generator函数
* 尾调用优化：只保留内层函数的调用帧(暂时不了解)
  * 详情见[尾调用优化](https://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96)
  * 尾调用
    * 定义：某个函数的最后一步是调用另一个函数
    * 形式：`function f(x) { return g(x); }`
  * 尾递归
    * 定义：函数尾调用自身
    * 作用：只要使用尾递归就不会发生栈溢出，相对节省内存
    * 实现：把所有用到的内部变量改写成函数的参数并使用参数默认值
## 箭头函数误区
* 函数体内的this是定义时所在的对象而不是使用时所在的对象
* 可让this指向固定化，这种特性很有利于封装回调函数
* 不可当作构造函数，因此箭头函数不可使用new命令
* 不可使用yield命令，因此箭头函数不能用作Generator函数
* 不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替)
 * 不适用场合
    * 定义对象方法
      ```js
      const cat = {
        lives: 9,
        jumps: () => {
          this.lives--;
        }
      }
      ```
      对象不会构成单独的作用域，所以this会被绑定到全局上
    * 动态this
      ```js
      var button = document.getElementById('press');
      button.addEventListener('click', () => {
        this.classList.toggle('on');
      });
      ```返回对象时必须在对象外面加上括号
- - -









